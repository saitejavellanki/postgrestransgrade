# views.py - Fixed version with proper error handling for ScriptImage
from django.shortcuts import render
import json
from django.http import JsonResponse
from django.views import View
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.db import IntegrityError
from django.core.exceptions import ValidationError
import logging

from .models import Class, Student, Subject, Script, OCRData, KeyOCR, ScriptImage, TextractOCR, CompareText, Result

# Set up logging
logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class ClassView(View):
    def get(self, request):
        data = list(Class.objects.values())
        return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            data = json.loads(request.body)
            new_class = Class.objects.create(class_name=data['class_name'])
            return JsonResponse({'message': 'Class created', 'class_id': new_class.class_id})
        except IntegrityError:
            return JsonResponse({'error': 'Class name already exists'}, status=400)
        except Exception as e:
            logger.error(f"ClassView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class StudentView(View):
    def get(self, request):
        # Get class_id from query parameters if provided
        class_id = request.GET.get('class_id')
        
        if class_id:
            # Return students for specific class
            try:
                class_obj = Class.objects.get(class_id=class_id)
                students = Student.objects.filter(class_id=class_obj)
                data = []
                for student in students:
                    data.append({
                        'student_id': student.student_id,
                        'name': student.name,
                        'roll_number': student.roll_number,
                        'class_id': student.class_id.class_id,
                        'class_name': student.class_id.class_name
                    })
                return JsonResponse(data, safe=False)
            except Class.DoesNotExist:
                return JsonResponse({'error': 'Invalid class_id'}, status=400)
        else:
            # Return all students with class information
            students = Student.objects.select_related('class_id').all()
            data = []
            for student in students:
                data.append({
                    'student_id': student.student_id,
                    'name': student.name,
                    'roll_number': student.roll_number,
                    'class_id': student.class_id.class_id,
                    'class_name': student.class_id.class_name
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            data = json.loads(request.body)
            
            # Get the actual Class object from DB
            class_obj = Class.objects.get(class_id=data['class_id'])
            student = Student.objects.create(
                name=data['name'],
                roll_number=data['roll_number'],
                class_id=class_obj
            )

            return JsonResponse({'message': 'Student created', 'student_id': student.student_id})
        
        except Class.DoesNotExist:
            return JsonResponse({'error': 'Invalid class_id'}, status=400)
        except IntegrityError:
            return JsonResponse({'error': 'Student with this roll number already exists in this class'}, status=400)
        except Exception as e:
            logger.error(f"StudentView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class SubjectView(View):
    def get(self, request):
        # Get class_id from query parameters if provided
        class_id = request.GET.get('class_id')
        
        if class_id:
            # Return subjects for specific class
            try:
                class_obj = Class.objects.get(class_id=class_id)
                subjects = Subject.objects.filter(class_id=class_obj)
                data = []
                for subject in subjects:
                    # Check if key OCR exists for this subject
                    has_key_ocr = hasattr(subject, 'key_ocr') and subject.key_ocr is not None
                    data.append({
                        'subject_id': subject.subject_id,
                        'subject_name': subject.subject_name,
                        'class_id': subject.class_id.class_id,
                        'class_name': subject.class_id.class_name,
                        'has_key_ocr': has_key_ocr
                    })
                return JsonResponse(data, safe=False)
            except Class.DoesNotExist:
                return JsonResponse({'error': 'Invalid class_id'}, status=400)
        else:
            # Return all subjects with class information
            subjects = Subject.objects.select_related('class_id').all()
            data = []
            for subject in subjects:
                # Check if key OCR exists for this subject
                has_key_ocr = hasattr(subject, 'key_ocr') and subject.key_ocr is not None
                data.append({
                    'subject_id': subject.subject_id,
                    'subject_name': subject.subject_name,
                    'class_id': subject.class_id.class_id,
                    'class_name': subject.class_id.class_name,
                    'has_key_ocr': has_key_ocr
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            data = json.loads(request.body)
            subject_name = data['subject_name'].strip()
            class_id = data['class_id']
            
            # Validate that class exists
            try:
                class_obj = Class.objects.get(class_id=class_id)
            except Class.DoesNotExist:
                return JsonResponse({'error': 'Invalid class_id'}, status=400)
            
            # Check if subject already exists for this specific class
            if Subject.objects.filter(
                subject_name__iexact=subject_name, 
                class_id=class_obj
            ).exists():
                return JsonResponse({
                    'error': f'Subject "{subject_name}" already exists for class "{class_obj.class_name}"'
                }, status=400)
            
            # Create subject for this class
            subject = Subject.objects.create(
                subject_name=subject_name,
                class_id=class_obj
            )
            
            return JsonResponse({
                'message': 'Subject created successfully',
                'subject_id': subject.subject_id,
                'class_name': class_obj.class_name
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"SubjectView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class KeyOCRView(View):
    def get(self, request):
        # Get subject_id from query parameters if provided
        subject_id = request.GET.get('subject_id')
        
        if subject_id:
            try:
                key_ocr = KeyOCR.objects.select_related('subject', 'subject__class_id').get(subject_id=subject_id)
                data = {
                    'key_ocr_id': key_ocr.key_ocr_id,
                    'subject_id': key_ocr.subject.subject_id,
                    'subject_name': key_ocr.subject.subject_name,
                    'class_id': key_ocr.subject.class_id.class_id,
                    'class_name': key_ocr.subject.class_id.class_name,
                    'key_json': key_ocr.key_json,
                    'context': key_ocr.context,
                    'rubrics': key_ocr.rubrics,
                    'created_at': key_ocr.created_at,
                    'updated_at': key_ocr.updated_at
                }
                return JsonResponse(data)
            except KeyOCR.DoesNotExist:
                return JsonResponse({'error': 'Key OCR not found for this subject'}, status=404)
        else:
            # Return all key OCRs
            key_ocrs = KeyOCR.objects.select_related('subject', 'subject__class_id').all()
            data = []
            for key_ocr in key_ocrs:
                data.append({
                    'key_ocr_id': key_ocr.key_ocr_id,
                    'subject_id': key_ocr.subject.subject_id,
                    'subject_name': key_ocr.subject.subject_name,
                    'class_id': key_ocr.subject.class_id.class_id,
                    'class_name': key_ocr.subject.class_id.class_name,
                    'key_json': key_ocr.key_json,
                    'context': key_ocr.context,
                    'rubrics': key_ocr.rubrics,
                    'created_at': key_ocr.created_at,
                    'updated_at': key_ocr.updated_at
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            data = json.loads(request.body)
            
            # Validate that subject exists
            try:
                subject = Subject.objects.get(subject_id=data['subject_id'])
            except Subject.DoesNotExist:
                return JsonResponse({'error': 'Invalid subject_id'}, status=400)
            
            # Check if key OCR already exists for this subject
            if KeyOCR.objects.filter(subject=subject).exists():
                return JsonResponse({
                    'error': f'Key OCR already exists for subject "{subject.subject_name}"'
                }, status=400)
            
            # Create key OCR - make context and rubrics optional
            key_ocr = KeyOCR.objects.create(
                subject=subject,
                key_json=data['key_json'],
                context=data.get('context', ''),  # Use empty string as default if context not provided
                rubrics=data.get('rubrics', '')  # Use empty string as default if rubrics not provided
            )
            
            return JsonResponse({
                'message': 'Key OCR created successfully',
                'key_ocr_id': key_ocr.key_ocr_id,
                'subject_name': subject.subject_name,
                'class_name': subject.class_id.class_name
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"KeyOCRView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def put(self, request):
        try:
            data = json.loads(request.body)
            
            # Get key OCR by subject_id or key_ocr_id
            if 'subject_id' in data:
                try:
                    key_ocr = KeyOCR.objects.get(subject_id=data['subject_id'])
                except KeyOCR.DoesNotExist:
                    return JsonResponse({'error': 'Key OCR not found for this subject'}, status=404)
            elif 'key_ocr_id' in data:
                try:
                    key_ocr = KeyOCR.objects.get(key_ocr_id=data['key_ocr_id'])
                except KeyOCR.DoesNotExist:
                    return JsonResponse({'error': 'Key OCR not found'}, status=404)
            else:
                return JsonResponse({'error': 'Either subject_id or key_ocr_id is required'}, status=400)
            
            # Only update fields that are provided and not empty
            if 'key_json' in data and data['key_json']:  # Only update if key_json is provided and not empty
                key_ocr.key_json = data['key_json']
            
            if 'context' in data:  # Update context if provided (even if empty string)
                key_ocr.context = data['context']
            
            if 'rubrics' in data:  # Update rubrics if provided (even if empty string)
                key_ocr.rubrics = data['rubrics']
            
            key_ocr.save()
            
            return JsonResponse({
                'message': 'Key OCR updated successfully',
                'key_ocr_id': key_ocr.key_ocr_id
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"KeyOCRView PUT error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class ScriptView(View):
    def get(self, request):
        # Get query parameters for filtering
        student_id = request.GET.get('student_id')
        subject_id = request.GET.get('subject_id')
        class_id = request.GET.get('class_id')
        
        scripts = Script.objects.select_related('student', 'subject', 'class_id')
        
        # Apply filters if provided
        if student_id:
            scripts = scripts.filter(student=student_id)
        if subject_id:
            scripts = scripts.filter(subject=subject_id)
        if class_id:
            scripts = scripts.filter(class_id=class_id)
        
        data = []
        for script in scripts:
            data.append({
                'script_id': script.script_id,
                'student_id': script.student.student_id,
                'student_name': script.student.name,
                'subject_id': script.subject.subject_id,
                'subject_name': script.subject.subject_name,
                'class_id': script.class_id.class_id,
                'class_name': script.class_id.class_name,
                'uploaded_at': script.uploaded_at
            })
        return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            data = json.loads(request.body)
            
            # Validate that student and subject exist
            try:
                student = Student.objects.get(student_id=data['student_id'])
                subject = Subject.objects.get(subject_id=data['subject_id'])
            except Student.DoesNotExist:
                return JsonResponse({'error': 'Invalid student_id'}, status=400)
            except Subject.DoesNotExist:
                return JsonResponse({'error': 'Invalid subject_id'}, status=400)
            
            # Validate that student and subject belong to same class
            if student.class_id != subject.class_id:
                return JsonResponse({
                    'error': 'Student and subject must belong to the same class'
                }, status=400)
            
            # Check if script already exists
            existing_script = Script.objects.filter(
                student=student,
                subject=subject
            ).first()
            
            if existing_script:
                return JsonResponse({
                    'error': f'Script already exists for student {student.name} and subject {subject.subject_name}',
                    'script_id': existing_script.script_id
                }, status=400)
            
            # Create new script - class_id will be auto-populated from student's class
            script = Script.objects.create(
                student=student,
                subject=subject,
                class_id=student.class_id  # Explicitly set class_id
            )
            return JsonResponse({
                'message': 'Script created',
                'script_id': script.script_id,
                'class_id': script.class_id.class_id,
                'class_name': script.class_id.class_name
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except IntegrityError as e:
            logger.error(f"ScriptView POST IntegrityError: {str(e)}")
            return JsonResponse({'error': f'Script already exists for this student and subject'}, status=400)
        except Exception as e:
            logger.error(f"ScriptView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class ScriptImageView(View):
    def get(self, request):
        # Get query parameters for filtering
        script_id = request.GET.get('script_id')
        
        if script_id:
            # Return images for specific script
            try:
                script = Script.objects.get(script_id=script_id)
                images = ScriptImage.objects.filter(script=script).order_by('page_number')
                data = []
                for image in images:
                    data.append({
                        'image_id': image.image_id,
                        'script_id': image.script.script_id,
                        'page_number': image.page_number,
                        'image_data': image.image_data,
                        'image_filename': image.image_filename,
                        'image_path': image.image_path,
                        'created_at': image.created_at
                    })
                return JsonResponse(data, safe=False)
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
        else:
            # Return all script images
            images = ScriptImage.objects.select_related('script').all()
            data = []
            for image in images:
                data.append({
                    'image_id': image.image_id,
                    'script_id': image.script.script_id,
                    'page_number': image.page_number,
                    'image_data': image.image_data,
                    'image_filename': image.image_filename,
                    'image_path': image.image_path,
                    'created_at': image.created_at
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            # Log the incoming request for debugging
            logger.info(f"ScriptImageView POST request received")
            
            # Parse JSON data
            try:
                data = json.loads(request.body)
                logger.info(f"Parsed JSON data keys: {list(data.keys())}")
            except json.JSONDecodeError as e:
                logger.error(f"JSON decode error: {str(e)}")
                return JsonResponse({'error': 'Invalid JSON data'}, status=400)
            
            # Validate required fields
            required_fields = ['script_id', 'page_number', 'image_data', 'image_filename']
            missing_fields = [field for field in required_fields if field not in data or data[field] is None]
            
            if missing_fields:
                logger.error(f"Missing required fields: {missing_fields}")
                return JsonResponse({'error': f'Missing required fields: {", ".join(missing_fields)}'}, status=400)
            
            # Validate data types and values
            try:
                script_id = int(data['script_id'])
                page_number = int(data['page_number'])
            except (ValueError, TypeError) as e:
                logger.error(f"Invalid data types: {str(e)}")
                return JsonResponse({'error': 'script_id and page_number must be integers'}, status=400)
            
            if page_number < 1:
                return JsonResponse({'error': 'page_number must be greater than 0'}, status=400)
            
            # Validate that script exists
            try:
                script = Script.objects.get(script_id=script_id)
                logger.info(f"Found script: {script}")
            except Script.DoesNotExist:
                logger.error(f"Script not found: {script_id}")
                return JsonResponse({'error': f'Script with ID {script_id} not found'}, status=400)
            
            # Check for existing image with same script and page number
            existing_image = ScriptImage.objects.filter(
                script=script,
                page_number=page_number
            ).first()
            
            if existing_image:
                logger.warning(f"Image already exists for script {script_id}, page {page_number}")
                return JsonResponse({
                    'error': f'Image already exists for script {script_id}, page {page_number}',
                    'image_id': existing_image.image_id
                }, status=400)
            
            # Validate image data
            image_data = data['image_data']
            if not isinstance(image_data, str) or len(image_data.strip()) == 0:
                return JsonResponse({'error': 'image_data must be a non-empty string'}, status=400)
            
            # Validate filename
            image_filename = data['image_filename'].strip()
            if not image_filename:
                return JsonResponse({'error': 'image_filename cannot be empty'}, status=400)
            
            # Create script image with proper error handling
            try:
                image = ScriptImage.objects.create(
                    script=script,
                    page_number=page_number,
                    image_data=image_data,
                    image_filename=image_filename,
                    image_path=data.get('image_path', '').strip()
                )
                
                logger.info(f"Successfully created ScriptImage: {image.image_id}")
                
                return JsonResponse({
                    'message': 'Script image saved successfully',
                    'image_id': image.image_id,
                    'script_id': script.script_id,
                    'page_number': image.page_number,
                    'image_filename': image.image_filename
                })
                
            except IntegrityError as e:
                logger.error(f"IntegrityError creating ScriptImage: {str(e)}")
                return JsonResponse({
                    'error': f'Image already exists for script {script_id}, page {page_number}'
                }, status=400)
            except ValidationError as e:
                logger.error(f"ValidationError creating ScriptImage: {str(e)}")
                return JsonResponse({'error': f'Validation error: {str(e)}'}, status=400)
            except Exception as e:
                logger.error(f"Unexpected error creating ScriptImage: {str(e)}")
                return JsonResponse({'error': f'Database error: {str(e)}'}, status=500)
                
        except KeyError as e:
            logger.error(f"KeyError in ScriptImageView POST: {str(e)}")
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"Unexpected error in ScriptImageView POST: {str(e)}")
            return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class OCRDataView(View):
    def get(self, request):
        # Get query parameters for filtering
        script_id = request.GET.get('script_id')
        
        if script_id:
            # Return OCR data for specific script
            try:
                script = Script.objects.get(script_id=script_id)
                ocr_data = OCRData.objects.filter(script=script).order_by('page_number')
                data = []
                for ocr in ocr_data:
                    data.append({
                        'ocr_id': ocr.ocr_id,
                        'script_id': ocr.script.script_id,
                        'page_number': ocr.page_number,
                        'ocr_json': ocr.ocr_json,
                        'structured_json': ocr.structured_json,
                        'context': ocr.context,
                        'created_at': ocr.created_at
                    })
                return JsonResponse(data, safe=False)
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
        else:
            # Return all OCR data
            ocr_data = OCRData.objects.select_related('script').all()
            data = []
            for ocr in ocr_data:
                data.append({
                    'ocr_id': ocr.ocr_id,
                    'script_id': ocr.script.script_id,
                    'page_number': ocr.page_number,
                    'ocr_json': ocr.ocr_json,
                    'structured_json': ocr.structured_json,
                    'context': ocr.context,
                    'created_at': ocr.created_at
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            data = json.loads(request.body)
            
            # Validate that script exists
            try:
                script = Script.objects.get(script_id=data['script_id'])
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
            
            # Create OCR data
            ocr = OCRData.objects.create(
                script=script,
                page_number=data['page_number'],
                ocr_json=data['ocr_json'],
                structured_json=data['structured_json'],
                context=data['context']
            )
            return JsonResponse({
                'message': 'OCR Data created',
                'ocr_id': ocr.ocr_id,
                'script_id': script.script_id
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except IntegrityError:
            return JsonResponse({'error': 'OCR data already exists for this script and page number'}, status=400)
        except Exception as e:
            logger.error(f"OCRDataView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

# Add this import to your views.py file


@method_decorator(csrf_exempt, name='dispatch')
class TextractOCRView(View):
    def get(self, request):
        # Get query parameters for filtering
        script_id = request.GET.get('script_id')
        page_number = request.GET.get('page_number')
        processing_status = request.GET.get('processing_status')
        
        textract_ocr = TextractOCR.objects.select_related('script')
        
        # Apply filters if provided
        if script_id:
            try:
                script = Script.objects.get(script_id=script_id)
                textract_ocr = textract_ocr.filter(script=script)
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
        
        if page_number:
            try:
                page_num = int(page_number)
                textract_ocr = textract_ocr.filter(page_number=page_num)
            except ValueError:
                return JsonResponse({'error': 'page_number must be an integer'}, status=400)
        
        if processing_status:
            valid_statuses = ['pending', 'processing', 'completed', 'failed']
            if processing_status not in valid_statuses:
                return JsonResponse({'error': f'Invalid processing_status. Must be one of: {", ".join(valid_statuses)}'}, status=400)
            textract_ocr = textract_ocr.filter(processing_status=processing_status)
        
        # Order by script and page number
        textract_ocr = textract_ocr.order_by('script', 'page_number')
        
        data = []
        for ocr in textract_ocr:
            data.append({
                'textract_ocr_id': ocr.textract_ocr_id,
                'script_id': ocr.script.script_id,
                'student_name': ocr.script.student.name,
                'subject_name': ocr.script.subject.subject_name,
                'class_name': ocr.script.class_id.class_name,
                'page_number': ocr.page_number,
                'extracted_text_json': ocr.extracted_text_json,
                'confidence_score': ocr.confidence_score,
                'processing_status': ocr.processing_status,
                'error_message': ocr.error_message,
                'created_at': ocr.created_at,
                'updated_at': ocr.updated_at
            })
        return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            # Log the incoming request for debugging
            logger.info(f"TextractOCRView POST request received")
            
            # Parse JSON data
            try:
                data = json.loads(request.body)
                logger.info(f"Parsed JSON data keys: {list(data.keys())}")
            except json.JSONDecodeError as e:
                logger.error(f"JSON decode error: {str(e)}")
                return JsonResponse({'error': 'Invalid JSON data'}, status=400)
            
            # Validate required fields
            required_fields = ['script_id', 'page_number', 'extracted_text_json']
            missing_fields = [field for field in required_fields if field not in data or data[field] is None]
            
            if missing_fields:
                logger.error(f"Missing required fields: {missing_fields}")
                return JsonResponse({'error': f'Missing required fields: {", ".join(missing_fields)}'}, status=400)
            
            # Validate data types and values
            try:
                script_id = int(data['script_id'])
                page_number = int(data['page_number'])
            except (ValueError, TypeError) as e:
                logger.error(f"Invalid data types: {str(e)}")
                return JsonResponse({'error': 'script_id and page_number must be integers'}, status=400)
            
            if page_number < 1:
                return JsonResponse({'error': 'page_number must be greater than 0'}, status=400)
            
            # Validate that script exists
            try:
                script = Script.objects.get(script_id=script_id)
                logger.info(f"Found script: {script}")
            except Script.DoesNotExist:
                logger.error(f"Script not found: {script_id}")
                return JsonResponse({'error': f'Script with ID {script_id} not found'}, status=400)
            
            # Check for existing TextractOCR with same script and page number
            existing_ocr = TextractOCR.objects.filter(
                script=script,
                page_number=page_number
            ).first()
            
            if existing_ocr:
                logger.warning(f"TextractOCR already exists for script {script_id}, page {page_number}")
                return JsonResponse({
                    'error': f'TextractOCR already exists for script {script_id}, page {page_number}',
                    'textract_ocr_id': existing_ocr.textract_ocr_id
                }, status=400)
            
            # Validate processing status if provided
            processing_status = data.get('processing_status', 'completed')
            valid_statuses = ['pending', 'processing', 'completed', 'failed']
            if processing_status not in valid_statuses:
                return JsonResponse({'error': f'Invalid processing_status. Must be one of: {", ".join(valid_statuses)}'}, status=400)
            
            # Validate confidence score if provided
            confidence_score = data.get('confidence_score')
            if confidence_score is not None:
                try:
                    confidence_score = float(confidence_score)
                    if not (0.0 <= confidence_score <= 1.0):
                        return JsonResponse({'error': 'confidence_score must be between 0.0 and 1.0'}, status=400)
                except (ValueError, TypeError):
                    return JsonResponse({'error': 'confidence_score must be a valid number'}, status=400)
            
            # Create TextractOCR with proper error handling
            try:
                textract_ocr = TextractOCR.objects.create(
                    script=script,
                    page_number=page_number,
                    extracted_text_json=data['extracted_text_json'],
                    confidence_score=confidence_score,
                    processing_status=processing_status,
                    error_message=data.get('error_message', '')
                )
                
                logger.info(f"Successfully created TextractOCR: {textract_ocr.textract_ocr_id}")
                
                return JsonResponse({
                    'message': 'TextractOCR created successfully',
                    'textract_ocr_id': textract_ocr.textract_ocr_id,
                    'script_id': script.script_id,
                    'page_number': textract_ocr.page_number,
                    'processing_status': textract_ocr.processing_status
                })
                
            except IntegrityError as e:
                logger.error(f"IntegrityError creating TextractOCR: {str(e)}")
                return JsonResponse({
                    'error': f'TextractOCR already exists for script {script_id}, page {page_number}'
                }, status=400)
            except ValidationError as e:
                logger.error(f"ValidationError creating TextractOCR: {str(e)}")
                return JsonResponse({'error': f'Validation error: {str(e)}'}, status=400)
            except Exception as e:
                logger.error(f"Unexpected error creating TextractOCR: {str(e)}")
                return JsonResponse({'error': f'Database error: {str(e)}'}, status=500)
                
        except KeyError as e:
            logger.error(f"KeyError in TextractOCRView POST: {str(e)}")
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"Unexpected error in TextractOCRView POST: {str(e)}")
            return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)

    def put(self, request):
        try:
            data = json.loads(request.body)
            
            # Get TextractOCR by textract_ocr_id
            if 'textract_ocr_id' not in data:
                return JsonResponse({'error': 'textract_ocr_id is required for updates'}, status=400)
            
            try:
                textract_ocr = TextractOCR.objects.get(textract_ocr_id=data['textract_ocr_id'])
            except TextractOCR.DoesNotExist:
                return JsonResponse({'error': 'TextractOCR not found'}, status=404)
            
            # Update fields that are provided
            if 'extracted_text_json' in data and data['extracted_text_json']:
                textract_ocr.extracted_text_json = data['extracted_text_json']
            
            if 'confidence_score' in data:
                confidence_score = data['confidence_score']
                if confidence_score is not None:
                    try:
                        confidence_score = float(confidence_score)
                        if not (0.0 <= confidence_score <= 1.0):
                            return JsonResponse({'error': 'confidence_score must be between 0.0 and 1.0'}, status=400)
                        textract_ocr.confidence_score = confidence_score
                    except (ValueError, TypeError):
                        return JsonResponse({'error': 'confidence_score must be a valid number'}, status=400)
                else:
                    textract_ocr.confidence_score = None
            
            if 'processing_status' in data:
                processing_status = data['processing_status']
                valid_statuses = ['pending', 'processing', 'completed', 'failed']
                if processing_status not in valid_statuses:
                    return JsonResponse({'error': f'Invalid processing_status. Must be one of: {", ".join(valid_statuses)}'}, status=400)
                textract_ocr.processing_status = processing_status
            
            if 'error_message' in data:
                textract_ocr.error_message = data['error_message']
            
            textract_ocr.save()
            
            return JsonResponse({
                'message': 'TextractOCR updated successfully',
                'textract_ocr_id': textract_ocr.textract_ocr_id,
                'processing_status': textract_ocr.processing_status
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"TextractOCRView PUT error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)
        
@method_decorator(csrf_exempt, name='dispatch')
class CombinedDataView(View):
    def get(self, request):
        try:
            # Get query parameters
            subject_id = request.GET.get('subject_id')
            script_id = request.GET.get('script_id')
            
            # Validate that at least one parameter is provided
            if not subject_id and not script_id:
                return JsonResponse({
                    'error': 'Either subject_id or script_id is required'
                }, status=400)
            
            response_data = {}
            
            # Retrieve context from KeyOCR based on subject_id
            if subject_id:
                try:
                    subject_id = int(subject_id)
                    
                    try:
                        key_ocr = KeyOCR.objects.select_related('subject', 'subject__class_id').get(subject_id=subject_id)
                        response_data['context'] = key_ocr.context
                    except KeyOCR.DoesNotExist:
                        response_data['context'] = None
                    
                except (ValueError, TypeError):
                    response_data['context'] = None
            
            # Retrieve OCR JSON and Textract results based on script_id
            if script_id:
                try:
                    script_id = int(script_id)
                    
                    try:
                        script = Script.objects.select_related('student', 'subject', 'class_id').get(script_id=script_id)
                        
                        # Get OCR JSON data
                        ocr_data = OCRData.objects.filter(script=script).order_by('page_number')
                        
                        if ocr_data.exists():
                            ocr_json_data = []
                            seen_ocr_data = set()
                            
                            for ocr in ocr_data:
                                current_ocr_data = None
                                
                                if isinstance(ocr.ocr_json, (list, dict)):
                                    current_ocr_data = ocr.ocr_json
                                elif isinstance(ocr.ocr_json, str):
                                    try:
                                        current_ocr_data = json.loads(ocr.ocr_json)
                                    except json.JSONDecodeError:
                                        current_ocr_data = ocr.ocr_json
                                else:
                                    current_ocr_data = ocr.ocr_json
                                
                                # Handle deduplication for OCR data
                                if isinstance(current_ocr_data, list):
                                    for item in current_ocr_data:
                                        item_hash = hash(json.dumps(item, sort_keys=True) if isinstance(item, dict) else str(item))
                                        if item_hash not in seen_ocr_data:
                                            seen_ocr_data.add(item_hash)
                                            ocr_json_data.append(item)
                                else:
                                    item_hash = hash(json.dumps(current_ocr_data, sort_keys=True) if isinstance(current_ocr_data, dict) else str(current_ocr_data))
                                    if item_hash not in seen_ocr_data:
                                        seen_ocr_data.add(item_hash)
                                        ocr_json_data.append(current_ocr_data)
                            
                            response_data['ocr_json'] = ocr_json_data
                        else:
                            response_data['ocr_json'] = []
                        
                        # Get Textract results
                        textract_data = TextractOCR.objects.filter(script=script).order_by('page_number')
                        
                        if textract_data.exists():
                            textract_results = []
                            seen_textract_data = set()
                            
                            for textract_ocr in textract_data:
                                current_textract_data = None
                                
                                if isinstance(textract_ocr.extracted_text_json, (list, dict)):
                                    current_textract_data = textract_ocr.extracted_text_json
                                elif isinstance(textract_ocr.extracted_text_json, str):
                                    try:
                                        current_textract_data = json.loads(textract_ocr.extracted_text_json)
                                    except json.JSONDecodeError:
                                        current_textract_data = textract_ocr.extracted_text_json
                                else:
                                    current_textract_data = textract_ocr.extracted_text_json
                                
                                # Create simplified Textract entry
                                textract_entry = {
                                    'page_number': textract_ocr.page_number,
                                    'extracted_text': current_textract_data,
                                    'confidence_score': textract_ocr.confidence_score,
                                    'processing_status': textract_ocr.processing_status
                                }
                                
                                # Handle deduplication
                                entry_hash = hash(json.dumps(textract_entry, sort_keys=True, default=str))
                                if entry_hash not in seen_textract_data:
                                    seen_textract_data.add(entry_hash)
                                    textract_results.append(textract_entry)
                            
                            response_data['textract_results'] = textract_results
                        else:
                            response_data['textract_results'] = []
                            
                    except Script.DoesNotExist:
                        response_data['ocr_json'] = []
                        response_data['textract_results'] = []
                        
                except (ValueError, TypeError):
                    response_data['ocr_json'] = []
                    response_data['textract_results'] = []
            
            return JsonResponse(response_data)
            
        except Exception as e:
            logger.error(f"CombinedDataView GET error: {str(e)}")
            return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class CompareTextView(View):
    def get(self, request):
        # Get query parameters for filtering
        script_id = request.GET.get('script_id')
        compare_text_id = request.GET.get('compare_text_id')
        
        if compare_text_id:
            # Return specific compare text record
            try:
                compare_text = CompareText.objects.select_related('script', 'script__student', 'script__subject', 'script__class_id').get(compare_text_id=compare_text_id)
                data = {
                    'compare_text_id': compare_text.compare_text_id,
                    'script_id': compare_text.script.script_id,
                    'student_name': compare_text.script.student.name,
                    'subject_name': compare_text.script.subject.subject_name,
                    'class_name': compare_text.script.class_id.class_name,
                    'vlmdesc': compare_text.vlmdesc,
                    'restructured': compare_text.restructured,
                    'final_corrected_text': compare_text.final_corrected_text,
                    'created_at': compare_text.created_at,
                    'updated_at': compare_text.updated_at
                }
                return JsonResponse(data)
            except CompareText.DoesNotExist:
                return JsonResponse({'error': 'CompareText record not found'}, status=404)
        
        elif script_id:
            # Return compare text records for specific script
            try:
                script = Script.objects.get(script_id=script_id)
                compare_texts = CompareText.objects.filter(script=script).order_by('-created_at')
                data = []
                for compare_text in compare_texts:
                    data.append({
                        'compare_text_id': compare_text.compare_text_id,
                        'script_id': compare_text.script.script_id,
                        'student_name': compare_text.script.student.name,
                        'subject_name': compare_text.script.subject.subject_name,
                        'class_name': compare_text.script.class_id.class_name,
                        'vlmdesc': compare_text.vlmdesc,
                        'restructured': compare_text.restructured,
                        'final_corrected_text': compare_text.final_corrected_text,
                        'created_at': compare_text.created_at,
                        'updated_at': compare_text.updated_at
                    })
                return JsonResponse(data, safe=False)
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
        
        else:
            # Return all compare text records
            compare_texts = CompareText.objects.select_related('script', 'script__student', 'script__subject', 'script__class_id').all()
            data = []
            for compare_text in compare_texts:
                data.append({
                    'compare_text_id': compare_text.compare_text_id,
                    'script_id': compare_text.script.script_id,
                    'student_name': compare_text.script.student.name,
                    'subject_name': compare_text.script.subject.subject_name,
                    'class_name': compare_text.script.class_id.class_name,
                    'vlmdesc': compare_text.vlmdesc,
                    'restructured': compare_text.restructured,
                    'final_corrected_text': compare_text.final_corrected_text,
                    'created_at': compare_text.created_at,
                    'updated_at': compare_text.updated_at
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        try:
            # Log the incoming request for debugging
            logger.info(f"CompareTextView POST request received")
            
            # Parse JSON data
            try:
                data = json.loads(request.body)
                logger.info(f"Parsed JSON data keys: {list(data.keys())}")
            except json.JSONDecodeError as e:
                logger.error(f"JSON decode error: {str(e)}")
                return JsonResponse({'error': 'Invalid JSON data'}, status=400)
            
            # Validate required fields
            required_fields = ['script_id', 'vlmdesc', 'restructured', 'final_corrected_text']
            missing_fields = [field for field in required_fields if field not in data or data[field] is None]
            
            if missing_fields:
                logger.error(f"Missing required fields: {missing_fields}")
                return JsonResponse({'error': f'Missing required fields: {", ".join(missing_fields)}'}, status=400)
            
            # Validate data types
            try:
                script_id = int(data['script_id'])
            except (ValueError, TypeError) as e:
                logger.error(f"Invalid data type for script_id: {str(e)}")
                return JsonResponse({'error': 'script_id must be an integer'}, status=400)
            
            # Validate that script exists
            try:
                script = Script.objects.get(script_id=script_id)
                logger.info(f"Found script: {script}")
            except Script.DoesNotExist:
                logger.error(f"Script not found: {script_id}")
                return JsonResponse({'error': f'Script with ID {script_id} not found'}, status=400)
            
            # Create CompareText with proper error handling
            try:
                compare_text = CompareText.objects.create(
                    script=script,
                    vlmdesc=data['vlmdesc'],
                    restructured=data['restructured'],
                    final_corrected_text=data['final_corrected_text']
                )
                
                logger.info(f"Successfully created CompareText: {compare_text.compare_text_id}")
                
                return JsonResponse({
                    'message': 'CompareText created successfully',
                    'compare_text_id': compare_text.compare_text_id,
                    'script_id': script.script_id
                })
                
            except ValidationError as e:
                logger.error(f"ValidationError creating CompareText: {str(e)}")
                return JsonResponse({'error': f'Validation error: {str(e)}'}, status=400)
            except Exception as e:
                logger.error(f"Unexpected error creating CompareText: {str(e)}")
                return JsonResponse({'error': f'Database error: {str(e)}'}, status=500)
                
        except KeyError as e:
            logger.error(f"KeyError in CompareTextView POST: {str(e)}")
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"Unexpected error in CompareTextView POST: {str(e)}")
            return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)

    def put(self, request):
        try:
            data = json.loads(request.body)
            
            # Get CompareText by compare_text_id
            if 'compare_text_id' not in data:
                return JsonResponse({'error': 'compare_text_id is required for updates'}, status=400)
            
            try:
                compare_text = CompareText.objects.get(compare_text_id=data['compare_text_id'])
            except CompareText.DoesNotExist:
                return JsonResponse({'error': 'CompareText record not found'}, status=404)
            
            # Update fields that are provided
            if 'vlmdesc' in data and data['vlmdesc'] is not None:
                compare_text.vlmdesc = data['vlmdesc']
            
            if 'restructured' in data and data['restructured'] is not None:
                compare_text.restructured = data['restructured']
            
            if 'final_corrected_text' in data and data['final_corrected_text'] is not None:
                compare_text.final_corrected_text = data['final_corrected_text']
            
            compare_text.save()
            
            return JsonResponse({
                'message': 'CompareText updated successfully',
                'compare_text_id': compare_text.compare_text_id
            })
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"CompareTextView PUT error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def delete(self, request):
        try:
            data = json.loads(request.body)
            
            # Get CompareText by compare_text_id
            if 'compare_text_id' not in data:
                return JsonResponse({'error': 'compare_text_id is required for deletion'}, status=400)
            
            try:
                compare_text = CompareText.objects.get(compare_text_id=data['compare_text_id'])
                compare_text_id = compare_text.compare_text_id
                compare_text.delete()
                
                return JsonResponse({
                    'message': 'CompareText deleted successfully',
                    'compare_text_id': compare_text_id
                })
                
            except CompareText.DoesNotExist:
                return JsonResponse({'error': 'CompareText record not found'}, status=404)
            
        except KeyError as e:
            return JsonResponse({'error': f'Missing required field: {str(e)}'}, status=400)
        except Exception as e:
            logger.error(f"CompareTextView DELETE error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)
        

@method_decorator(csrf_exempt, name='dispatch')
class ResultView(View):
    def get(self, request):
        # Get script_id from query parameters if provided
        script_id = request.GET.get('script_id')
        result_id = request.GET.get('result_id')
        
        if result_id:
            # Return specific result by result_id
            try:
                result = Result.objects.select_related('script__student', 'script__subject', 'script__class_id').get(result_id=result_id)
                data = {
                    'result_id': result.result_id,
                    'script_id': result.script.script_id,
                    'student_name': result.script.student.name,
                    'student_roll_number': result.script.student.roll_number,
                    'subject_name': result.script.subject.subject_name,
                    'class_name': result.script.class_id.class_name,
                    'restructuredtext': result.restructuredtext,
                    'scored': result.scored,
                    'graded': result.graded,
                    'created_at': result.created_at,
                    'updated_at': result.updated_at
                }
                return JsonResponse(data)
            except Result.DoesNotExist:
                return JsonResponse({'error': 'Result not found'}, status=404)
        
        elif script_id:
            # Return results for specific script
            try:
                script = Script.objects.get(script_id=script_id)
                results = Result.objects.filter(script=script).select_related('script__student', 'script__subject', 'script__class_id')
                data = []
                for result in results:
                    data.append({
                        'result_id': result.result_id,
                        'script_id': result.script.script_id,
                        'student_name': result.script.student.name,
                        'student_roll_number': result.script.student.roll_number,
                        'subject_name': result.script.subject.subject_name,
                        'class_name': result.script.class_id.class_name,
                        'restructuredtext': result.restructuredtext,
                        'scored': result.scored,
                        'graded': result.graded,
                        'created_at': result.created_at,
                        'updated_at': result.updated_at
                    })
                return JsonResponse(data, safe=False)
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
        else:
            # Return all results with related information
            results = Result.objects.select_related('script__student', 'script__subject', 'script__class_id').all()
            data = []
            for result in results:
                data.append({
                    'result_id': result.result_id,
                    'script_id': result.script.script_id,
                    'student_name': result.script.student.name,
                    'student_roll_number': result.script.student.roll_number,
                    'subject_name': result.script.subject.subject_name,
                    'class_name': result.script.class_id.class_name,
                    'restructuredtext': result.restructuredtext,
                    'scored': result.scored,
                    'graded': result.graded,
                    'created_at': result.created_at,
                    'updated_at': result.updated_at
                })
            return JsonResponse(data, safe=False)

    def post(self, request):
        """Create a new result record"""
        try:
            data = json.loads(request.body)
            script_id = data.get('script_id')
            
            if not script_id:
                return JsonResponse({'error': 'script_id is required'}, status=400)
            
            # Get the actual Script object from DB
            try:
                script_obj = Script.objects.get(script_id=script_id)
            except Script.DoesNotExist:
                return JsonResponse({'error': 'Invalid script_id'}, status=400)
            
            # Check if result already exists for this script
            if Result.objects.filter(script=script_obj).exists():
                return JsonResponse({'error': 'Result already exists for this script'}, status=400)
            
            # Create result with provided data (fields can be empty initially)
            result = Result.objects.create(
                script=script_obj,
                restructuredtext=data.get('restructuredtext', {}),
                scored=data.get('scored', ''),
                graded=data.get('graded', '')
            )

            return JsonResponse({
                'message': 'Result created successfully',
                'result_id': result.result_id,
                'script_id': script_obj.script_id
            })
        
        except Exception as e:
            logger.error(f"ResultView POST error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def put(self, request):
        """Update specific fields of an existing result"""
        try:
            data = json.loads(request.body)
            result_id = data.get('result_id')
            
            if not result_id:
                return JsonResponse({'error': 'result_id is required for updates'}, status=400)
            
            try:
                result = Result.objects.get(result_id=result_id)
            except Result.DoesNotExist:
                return JsonResponse({'error': 'Result not found'}, status=404)
            
            # Track which fields are being updated
            updated_fields = []
            
            # Update restructuredtext if provided
            if 'restructuredtext' in data:
                result.restructuredtext = data['restructuredtext']
                updated_fields.append('restructuredtext')
            
            # Update scored if provided
            if 'scored' in data:
                result.scored = data['scored']
                updated_fields.append('scored')
            
            # Update graded if provided
            if 'graded' in data:
                result.graded = data['graded']
                updated_fields.append('graded')
            
            if not updated_fields:
                return JsonResponse({'error': 'No valid fields provided for update'}, status=400)
            
            # Save the updated result
            result.save()
            
            return JsonResponse({
                'message': f'Result updated successfully. Updated fields: {", ".join(updated_fields)}',
                'result_id': result.result_id,
                'updated_fields': updated_fields
            })
        
        except Exception as e:
            logger.error(f"ResultView PUT error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def patch(self, request):
        """Alternative method for partial updates (same as PUT in this implementation)"""
        return self.put(request)

    def delete(self, request):
        """Delete a result record"""
        try:
            data = json.loads(request.body)
            result_id = data.get('result_id')
            
            if not result_id:
                return JsonResponse({'error': 'result_id is required for deletion'}, status=400)
            
            try:
                result = Result.objects.get(result_id=result_id)
                script_info = {
                    'script_id': result.script.script_id,
                    'student_name': result.script.student.name,
                    'subject_name': result.script.subject.subject_name
                }
                result.delete()
                
                return JsonResponse({
                    'message': 'Result deleted successfully',
                    'deleted_result_id': result_id,
                    'script_info': script_info
                })
            except Result.DoesNotExist:
                return JsonResponse({'error': 'Result not found'}, status=404)
        
        except Exception as e:
            logger.error(f"ResultView DELETE error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)